## NTAPI detection based on Nirvana Debugging

### Table Of Content

### Giới thiệu

Trong chủ đề `Process Injection` đã trình bày đến kĩ thuật Nirvana Debugging, kĩ thuật này cho phép đặt 1 Hook ngay phía sau Syscall. Chi tiết bài viết đã được đề cập trước đây: [Nirvana Debugging](https://github.com/vuongle-vigo/WinMalHack-Blog/blob/main/Process%20Injection/Nirvana%20Debugging/Nirvana%20Debugging%20Technique.md). Từ kĩ thuật này, mình có 1 ý tưởng sử dụng kĩ thuật để theo dõi các NTAPI được gọi trong malware.

![map](images/map.png)

### Ý tưởng

Việc triển khai yêu cầu phải đặt được Hook trên `Remote Process`, và rất may mắn là `NtSetInformationProcess` hỗ trợ việc này. 

```c
typedef NTSTATUS(WINAPI* NtSetInformationProcessPtr)(
	HANDLE ProcessHandle,
	UINT32 ProcessInformationClass,
	PVOID ProcessInformation,
	ULONG ProcessInformationLength
	);
```

Tuy nhiên trong quá trình triển khai, có 1 vấn đề đặt ra là làm sao để đặt hook đúng tại thời điểm chương trình sẽ chạy các hàm chức năng chính, thay vì các hàm khởi tạo. Vì nếu gọi `NtSetInformationProcess` quá sớm, tại thời điểm chương trình chưa khởi tạo xong, nó sẽ không thành công.

***CreateProcess với CREATE_SUSPENDED hoặc DEBUG_PROCESS***

Ý tưởng là sẽ thực hiện tạo Remote Process với 1 trong 2 tham số ở trên, tuy nhiên, với cách tạo process như vậy thì hàm `NtSetInformationProcess` vẫn không thể thực hiện được, chương trình sẽ bị crash. Nguyên nhân chính là các tiến trình được tạo bằng 2 cách trên hoàn toàn chưa thực hiện các bước khởi tạo môi trường, load các thư viện liên quan.

***Tìm hiểu về quá trình khởi tạo của 1 tiến trình (Windows Process Loader)***

Bất cứ khi nào một quy trình mới được tạo, kernel sẽ ánh xạ hình ảnh của tệp thực thi đích vào bộ nhớ cùng với ntdll.dll. Sau đó, một luồng đơn được tạo ra, cuối cùng sẽ đóng vai trò là luồng điểm vào. Tại thời điểm này, quy trình này chỉ là một lớp vỏ trống (PEB, TEB và các nội dung nhập đều chưa được khởi tạo). Trước khi có thể gọi điểm nhập quy trình, phải thực hiện một chút thiết lập. 

Bất cứ khi nào một luồng mới bắt đầu, địa chỉ bắt đầu của nó sẽ được đặt thành `ntdll!LdrInitializeThunk()`, chịu trách nhiệm gọi 
`ntdll!LdrpInitialize()`.

`ntdll!LdrpInitialize()` có 2 mục đích:

1. Khởi tạo process (Nếu nó chưa được khởi tạo)
2. Khởi tạo thread ()

`ntdll!LdrpInitialize()` trước tiên sẽ kiểm tra biến toàn cục `ntdll!LdrpProcessInitialized`, nếu được đặt thành FALSE, sẽ dẫn đến lệnh gọi tới `ntdll!LdrpInitializeProcess()` trước khi khởi tạo luồng.

`ntdll!LdrpInitializeProcess()` thực hiện khởi tạo process. Nó sẽ thiết lập PEB, giải quyết quá trình nhập quy trình và tải mọi tệp DLL cần thiết.

Ngay ở cuối `ntdll!LdrpInitialize()` là lệnh gọi tới `ntdll!ZwTestAlert()`, đây là hàm được sử dụng để chạy tất cả Lệnh gọi thủ tục không đồng bộ (APC) trong hàng đợi APC của luồng hiện tại. Trình điều khiển EDR đưa mã vào quy trình đích và gọi nó qua ntoskrnl!NtQueueApcThread() sẽ thấy mã của chúng được thực thi tại đây. Như vậy có thể thấy lệnh gọi APC sẽ được thực thi ngay sau khi tiến trình khởi tạo thành công. 

Sau khi quá trình khởi tạo luồng và tiến trình hoàn tất và `ntdll!LdrpInitialize()` trả về, `ntdll!LdrInitializeThunk()` sẽ gọi `ntdll!ZwContinue()` để chuyển việc thực thi trở lại kernel. Sau đó, kernel sẽ đặt con trỏ lệnh luồng để trỏ tới `ntdll!RtlUserThreadStart()`, điểm này sẽ gọi điểm vào thực thi và vòng đời của quá trình chính thức bắt đầu.

Dưới đây là sơ đồ khởi tạo tiến trình:

![processmap](images/processmap.png)

***Xây dựng quá trình inject***

Từ việc tìm hiểu quá trình khởi tạo process ở trên, ta có thể thấy răng nếu sử dụng `APC Injection`, thì chương trình hoàn toàn có thể thực hiện các lệnh gọi khác, vì cơ bản, các thư viện lúc này đã được tải, tiến trình đã được khởi tạo xong. Về APC Injection, đã được triển khai trước đây: [APC Injection](https://github.com/vuongle-vigo/MalwareDevTechnique-Blog/tree/main/11-3-2024%20APC%20Injection).

Như vậy logic của quá trình này có thể tóm gọn thành các bước dưới đây:

- Ghi PE của tiến trình gốc vào remote process cần theo dõi, điều này giúp cho việc gọi các hàm sẽ triển khai.
- Triển khai `APC Injection` với phiên bản `Early Bird`, điểm đầu vào của inject sẽ là phần mã gọi `NtSetInformationProcess` đã được ghi vào remote process.
- Hàm `NtSetInformationProcess` triển khai với mã callback giúp ta lấy được giá trị thanh ghi `rax` và `r10`, đây là 2 thanh ghi quan trọng của `syscall`.
- Thực hiện mở pipe để truyền giá trị này về tiến trình gốc nhằm xử lý ở đó. Tại tiến trình gốc, gọi các lệnh đọc Symbol, dựa vào giá trị thanh ghi `rax`, `r10` trả về để phân tích.

### Triển khai code

Code đã được đính kèm theo bài viết, phần dưới đây sẽ triển khai 1 số mã quan trọng.

***Khởi tạo process***

Để thực hiện được `APC Injection` với phiên bản `Early Bird`, tiến trình cần được khởi tạo bằng chế độ `CREATE_SUSPENDED` hoặc `DEBUG_PROCESS`.

```c
void createProcess(LPSTR file_path) {
	LPSTARTUPINFOA si = new STARTUPINFOA();
	LPPROCESS_INFORMATION pi = new PROCESS_INFORMATION();
	PROCESS_BASIC_INFORMATION* pbi = new PROCESS_BASIC_INFORMATION();
	//C:\\Users\\vuong\\source\\repos\\Project2\\x64\\Debug\\Project2.exe
	//C:\\Windows\\System32\\notepad.exe
	if (!CreateProcessA((LPSTR)file_path, NULL, NULL, NULL, FALSE, DEBUG_PROCESS, NULL, NULL, si, pi)) {
		printf("[-] Can't create process");
		exit(-1);
	}

	hProc = pi->hProcess;
	hThread = pi->hThread;
	dwProcessId = pi->dwProcessId;
}
```

Với 2 chế độ này, sau đó có thể sử dụng 2 dòng lệnh sau để tiếp tục tiến trình. Tuy nhiên với `CREATE_SUSPENDED`, có vẻ như không còn khả thi trên win11, khi tiến trình cũ sẽ bị dừng và bắt đầu 1 tiến trình mới hoàn thành.

```c
//ResumeThread(hThread);
DebugActiveProcessStop(dwProcessId);
```

***Ghi PE Ordinal Process vào Remote Process***

Mã sau được triển khai gần như giống
```c
INT64 WritePEToTarget(HANDLE hTarget)
{
	// Get current image's base address
	PVOID imageBase = GetModuleHandle(NULL);
	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)imageBase;
	PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)imageBase + dosHeader->e_lfanew);

	// Allocate a new memory block and copy the current PE image to this new memory block
	PVOID localImage = VirtualAlloc(NULL, ntHeader->OptionalHeader.SizeOfImage, MEM_COMMIT, PAGE_READWRITE);
	memcpy(localImage, imageBase, ntHeader->OptionalHeader.SizeOfImage);

	HANDLE targetProcess = hTarget;

	// Allote a new memory block in the target process. This is where we will be injecting this PE
	PVOID targetImage = VirtualAllocEx(targetProcess, NULL, ntHeader->OptionalHeader.SizeOfImage, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	printf("targetImage: %I64X\n", targetImage);
	// Calculate delta between addresses of where the image will be located in the target process and where it's located currently
	INT64 deltaImageBase = (DWORD_PTR)targetImage - (DWORD_PTR)imageBase;
	printf("deltaImageBase: %I64X\n", deltaImageBase);
	DWORD_PTR x = deltaImageBase + (DWORD_PTR)callback;
	printf("x: %I64X\n", x);
	// Relocate localImage, to ensure that it will have correct addresses once its in the target process
	PIMAGE_BASE_RELOCATION relocationTable = (PIMAGE_BASE_RELOCATION)((DWORD_PTR)localImage + ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
	DWORD relocationEntriesCount = 0;
	PDWORD_PTR patchedAddress;
	PBASE_RELOCATION_ENTRY relocationRVA = NULL;

	while (relocationTable->SizeOfBlock > 0)
	{
		relocationEntriesCount = (relocationTable->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(USHORT);
		relocationRVA = (PBASE_RELOCATION_ENTRY)(relocationTable + 1);

		for (short i = 0; i < relocationEntriesCount; i++)
		{
			if (relocationRVA[i].Offset)
			{
				patchedAddress = (PDWORD_PTR)((DWORD_PTR)localImage + relocationTable->VirtualAddress + relocationRVA[i].Offset);
				*patchedAddress += deltaImageBase;
			}
		}
		relocationTable = (PIMAGE_BASE_RELOCATION)((DWORD_PTR)relocationTable + relocationTable->SizeOfBlock);
	}

	// Write the relocated localImage into the target process
	if (!WriteProcessMemory(targetProcess, targetImage, localImage, ntHeader->OptionalHeader.SizeOfImage, NULL)) {
		printf("Write Image to Target Process Failed With Error Code: %d\n", GetLastError());
		return -1;
	}
	/*printf("[+] Enter to write image\n");
	getchar();*/
	return deltaImageBase;
}
```

Đây là phần mã xử lý giá trị thanh ghi được gửi về để lấy tên NTAPI:

```c
if (strlen(buffer) != 0) {
	//printf("%s\n", buffer);
	unsigned long long r10, rax;
	char* next_token = nullptr;
	char* token = strtok_s(buffer, ":", &next_token);
	if (token != NULL) {
		r10 = stoll(token, NULL, 10);
		token = strtok_s(NULL, ":", &next_token);
		if (token != NULL) {
			rax = stoll(token, NULL, 10);
		}
	}
	BYTE* ptr = reinterpret_cast<BYTE*>(r10);
	unsigned __int32* mark;
	do {
		mark = reinterpret_cast<unsigned __int32*>(ptr);
		ptr--;
	} while (*mark != 0xb8d18b4c);
	ptr = ptr + 5;
	CHAR buffer[sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(TCHAR)] = { 0 };
	PSYMBOL_INFO pSymbol = (PSYMBOL_INFO)buffer;
	pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);
	pSymbol->MaxNameLen = MAX_SYM_NAME;
	DWORD64 Displacement = 0;
	BOOLEAN result = SymFromAddr(hProc, r10, &Displacement, pSymbol);
	if (result) {
		printf("Function name: %s\n", pSymbol->Name);
		printf("Syscall code: 0x%x\n", *ptr);
		printf("Function return: 0x%I64X\n", rax);
		printf("Function return address: 0x%I64X\n", r10);
		printf("***************************************************\n");
	}
}
```

Các lấy giá trị đã được triển khai ở bài viết [Syscall](https://github.com/vuongle-vigo/WinMalHack-Blog/tree/main/Process%20Injection/Bypass%20AV%20Hook%20-%20Direct%20Syscall).


### Demo
Phiên bản triển khai ở trên chỉ áp dụng cho x64, vì vậy sẽ demo trên mẫu mã độc x64, có thể tải ở [Malware Bazaar](https://bazaar.abuse.ch/browse/).

![Demo1](images/demo1.png)

Tiến hành chạy, ta thấy các NTAPI mà malware đã thực hiện lần lượt như dưới:

![demo2](images/demo2.png)

Như vậy dựa vào việc sử dụng kết hợp các kĩ thuật trên, đã có thể lấy được các NTAPI mà mã độc gọi, điều này có thể tránh được các kĩ thuật bypass AV như indirect & direct syscall, API hooking hay API Hashing.


### Update 1 (15/4/2024)

Giá trị của thanh ghi r10 sau khi syscall được gọi lập tức được đặt bằng địa chỉ lệnh ret ngay phía sau syscall. Đối với trường hợp direct syscall hay indirect syscall thì điều này xảy ra tương tự, khiến cho việc sử dụng phương pháp trên cho việc phát hiện NTAPI được gọi 100% là không chính xác. Vì vậy cần sử dụng thêm bảng đối chiếu hàm gọi thông qua SSN. Mình sẽ cập nhật mã sau.